package tests;
import java.util.List;
import java.util.Scanner;
import models.Process;
import scheduler.FIFO;

/**
 * Clase responsable de formatear y mostrar los resultados del algoritmo FIFO
 */
public class ResultFormatter {
    private Scanner scanner;
    
    public ResultFormatter() {
        this.scanner = new Scanner(System.in);
    }
    
    /**
     * Pausa la ejecuci√≥n hasta que el usuario presione Enter
     */
    private void waitForUser() {
        System.out.print("\nüìÑ Presione Enter para continuar a la siguiente secci√≥n...");
        scanner.nextLine();
    }
    
    /**
     * Muestra todos los resultados del simulador FIFO de forma completa
     * @param fifo Planificador FIFO con resultados calculados
     */
    public void displayCompleteResults(FIFO fifo) {
        if (!fifo.hasValidResults()) {
            System.out.println("‚ùå Error: No hay resultados v√°lidos para mostrar");
            return;
        }
        
        List<Process> processes = fifo.getProcessedProcesses();
        
        System.out.println("\n" + "=".repeat(60));
        System.out.println("           RESULTADOS DEL ALGORITMO FIFO");
        System.out.println("=".repeat(60));
        
        // 1. Orden de ejecuci√≥n del CPU
        displayExecutionOrder(fifo.getExecutionOrder());
        waitForUser();
        
        // 2. Tabla detallada de tiempos por proceso
        displayDetailedProcessTable(processes);
        waitForUser();
        
        // 3. M√©tricas individuales
        displayIndividualMetrics(processes);
        waitForUser();
        
        // 4. M√©tricas promedio
        displayAverageMetrics(fifo.getAverageWaitingTime(), fifo.getAverageTurnaroundTime());
        waitForUser();
        
        // 5. Cronograma de ejecuci√≥n
        displayExecutionTimeline(processes);
        
        System.out.println("=".repeat(60));
    }
    
    /**
     * Muestra el orden en que los procesos hacen uso del CPU
     * @param executionOrder Lista de procesos en orden de ejecuci√≥n
     */
    public void displayExecutionOrder(List<Process> executionOrder) {
        System.out.println("\nüîÑ ORDEN DE EJECUCI√ìN DEL CPU:");
        System.out.println("-".repeat(30));
        
        StringBuilder orderBuilder = new StringBuilder();
        for (int i = 0; i < executionOrder.size(); i++) {
            Process p = executionOrder.get(i);
            orderBuilder.append("P").append(p.getPid());
            if (i < executionOrder.size() - 1) {
                orderBuilder.append(" ‚Üí ");
            }
        }
        
        System.out.println("Orden: " + orderBuilder.toString());
        System.out.println("(Los procesos se ejecutan seg√∫n su tiempo de llegada)");
    }
    
    /**
     * Muestra una tabla detallada con todos los tiempos calculados
     * @param processes Lista de procesos con tiempos calculados
     */
    public void displayDetailedProcessTable(List<Process> processes) {
        System.out.println("\nüìä TABLA DETALLADA DE TIEMPOS:");
        System.out.println("-".repeat(40));
        
        // Encabezado de la tabla
        System.out.printf("%-10s %-10s %-10s\n", 
                "Proceso", "Llegada", "R√°faga");
        System.out.println("-".repeat(40));
        
        // Filas de datos
        for (Process process : processes) {
            System.out.printf("%-10s %-10d %-10d\n",
                    "P" + process.getPid(),
                    process.getArrivalTime(),
                    process.getBurstTime());
        }
        System.out.println("-".repeat(40));
    }
    
    /**
     * Muestra las m√©tricas individuales para cada proceso
     * @param processes Lista de procesos con m√©tricas calculadas
     */
    public void displayIndividualMetrics(List<Process> processes) {
        System.out.println("\n‚è±Ô∏è  M√âTRICAS INDIVIDUALES:");
        System.out.println("-".repeat(50));
        
        System.out.println("üìà Tiempo de Espera por proceso:");
        for (Process process : processes) {
            System.out.printf("   P%d: %d unidades de tiempo\n", 
                    process.getPid(), process.getWaitingTime());
        }
        
        System.out.println("\nüìà Tiempo de Retorno por proceso:");
        for (Process process : processes) {
            System.out.printf("   P%d: %d unidades de tiempo\n", 
                    process.getPid(), process.getTurnaroundTime());
        }
    }
    
    /**
     * Muestra las m√©tricas promedio del sistema
     * @param avgWaitingTime Tiempo medio de espera
     * @param avgTurnaroundTime Tiempo medio de retorno
     */
    public void displayAverageMetrics(double avgWaitingTime, double avgTurnaroundTime) {
        System.out.println("\nüéØ M√âTRICAS PROMEDIO DEL SISTEMA:");
        System.out.println("-".repeat(40));
        System.out.printf("‚è≥ Tiempo Medio de Espera:  %.2f unidades\n", avgWaitingTime);
        System.out.printf("üîÑ Tiempo Medio de Retorno: %.2f unidades\n", avgTurnaroundTime);
        
        // Interpretaci√≥n de resultados
        System.out.println("\nüí° Interpretaci√≥n:");
        if (avgWaitingTime <= 5) {
            System.out.println("   ‚úÖ Excelente tiempo de espera (‚â§ 5)");
        } else if (avgWaitingTime <= 10) {
            System.out.println("   ‚ö†Ô∏è  Tiempo de espera moderado (6-10)");
        } else {
            System.out.println("   ‚ùå Tiempo de espera alto (> 10)");
        }
        
        if (avgTurnaroundTime <= 15) {
            System.out.println("   ‚úÖ Excelente tiempo de retorno (‚â§ 15)");
        } else if (avgTurnaroundTime <= 25) {
            System.out.println("   ‚ö†Ô∏è  Tiempo de retorno moderado (16-25)");
        } else {
            System.out.println("   ‚ùå Tiempo de retorno alto (> 25)");
        }
    }
    
    /**
     * Muestra un cronograma visual de la ejecuci√≥n
     * @param processes Lista de procesos ordenados por ejecuci√≥n
     */
    public void displayExecutionTimeline(List<Process> processes) {
        System.out.println("\nüìÖ CRONOGRAMA DE EJECUCI√ìN:");
        System.out.println("-".repeat(50));
        
        // Encontrar el tiempo total
        int maxTime = 0;
        for (Process p : processes) {
            maxTime = Math.max(maxTime, p.getCompletionTime());
        }
        
        // Mostrar l√≠nea de tiempo
        System.out.print("Tiempo:  ");
        for (int t = 0; t <= maxTime; t++) {
            System.out.printf("%2d ", t);
        }
        System.out.println();
        
        System.out.print("CPU:     ");
        int currentTime = 0;
        for (Process process : processes) {
            // Tiempo inactivo antes del proceso
            while (currentTime < process.getStartTime()) {
                System.out.print(" - ");
                currentTime++;
            }
            
            // Ejecuci√≥n del proceso
            for (int t = process.getStartTime(); t < process.getCompletionTime(); t++) {
                System.out.printf("P%d ", process.getPid());
                currentTime++;
            }
        }
        System.out.println();
        
        // Leyenda
        System.out.println("\nLeyenda: Pn = Proceso n ejecut√°ndose, - = CPU inactivo");
    }
    
    /**
     * Muestra un resumen compacto de los resultados
     * @param fifo Planificador FIFO con resultados
     */
    public void displaySummary(FIFO fifo) {
        System.out.println("\nüìã RESUMEN EJECUTIVO:");
        System.out.println("-".repeat(30));
        
        List<Process> processes = fifo.getProcessedProcesses();
        System.out.printf("‚Ä¢ Procesos ejecutados: %d\n", processes.size());
        System.out.printf("‚Ä¢ Tiempo total de ejecuci√≥n: %d unidades\n", 
                getTotalExecutionTime(processes));
        System.out.printf("‚Ä¢ Tiempo medio de espera: %.1f unidades\n", 
                fifo.getAverageWaitingTime());
        System.out.printf("‚Ä¢ Tiempo medio de retorno: %.1f unidades\n", 
                fifo.getAverageTurnaroundTime());
        
        // Eficiencia del CPU
        double efficiency = calculateCpuEfficiency(processes);
        System.out.printf("‚Ä¢ Eficiencia del CPU: %.1f%%\n", efficiency);
    }
    
    /**
     * Calcula el tiempo total de ejecuci√≥n
     * @param processes Lista de procesos
     * @return Tiempo total de ejecuci√≥n
     */
    private int getTotalExecutionTime(List<Process> processes) {
        if (processes.isEmpty()) return 0;
        
        int maxCompletionTime = 0;
        for (Process p : processes) {
            maxCompletionTime = Math.max(maxCompletionTime, p.getCompletionTime());
        }
        return maxCompletionTime;
    }
    
    /**
     * Calcula la eficiencia del CPU
     * @param processes Lista de procesos
     * @return Porcentaje de eficiencia del CPU
     */
    private double calculateCpuEfficiency(List<Process> processes) {
        if (processes.isEmpty()) return 0.0;
        
        int totalBurstTime = 0;
        for (Process p : processes) {
            totalBurstTime += p.getBurstTime();
        }
        
        int totalExecutionTime = getTotalExecutionTime(processes);
        if (totalExecutionTime == 0) return 0.0;
        
        return (double) totalBurstTime / totalExecutionTime * 100.0;
    }
    
    /**
     * Cierra el scanner
     */
    public void close() {
        if (scanner != null) {
            scanner.close();
        }
    }
}